# 多轮对话上下文关联使用示例

## 概述

Text2SQL API 支持多轮对话，用户可以在第一轮生成的 SQL 基础上进行追加修改。系统通过 `conversation_id` 关联上下文，或者用户可以直接提供 `previous_sql`。

## 使用方式

### 方式1：使用 conversation_id（推荐）

#### 第一轮：创建新对话

**Request**:
```bash
curl -X POST http://localhost:8080/api/v1/sql/generate \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "查询所有年龄大于30的用户",
    "schema": {
      "tables": [
        {
          "name": "users",
          "columns": [
            {"name": "id", "type": "int", "comment": "用户ID"},
            {"name": "name", "type": "varchar(100)", "comment": "用户名"},
            {"name": "age", "type": "int", "comment": "年龄"},
            {"name": "status", "type": "varchar(20)", "comment": "状态"}
          ]
        }
      ]
    },
    "database": {
      "type": "mysql",
      "version": "8.0"
    }
  }'
```

**Response**:
```json
{
  "sql": "SELECT * FROM users WHERE age > 30",
  "explanation": "筛选年龄大于30的用户",
  "conversation_id": "conv_a1b2c3d4e5f6g7h8i9j0k1l2"
}
```

#### 第二轮：基于会话ID追加修改（schema/database 可省略）

**Request**:
```bash
curl -X POST http://localhost:8080/api/v1/sql/generate \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "还要筛选状态为active的用户",
    "conversation_id": "conv_a1b2c3d4e5f6g7h8i9j0k1l2"
  }'
```

**Response**:
```json
{
  "sql": "SELECT * FROM users WHERE age > 30 AND status = '\''active'\''",
  "explanation": "在原有查询基础上增加了状态筛选条件",
  "conversation_id": "conv_a1b2c3d4e5f6g7h8i9j0k1l2"
}
```

#### 第三轮：继续追加

**Request**:
```bash
curl -X POST http://localhost:8080/api/v1/sql/generate \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "按年龄降序排列",
    "conversation_id": "conv_a1b2c3d4e5f6g7h8i9j0k1l2"
  }'
```

**Response**:
```json
{
  "sql": "SELECT * FROM users WHERE age > 30 AND status = '\''active'\'' ORDER BY age DESC",
  "explanation": "在原有查询基础上增加了按年龄降序排列",
  "conversation_id": "conv_a1b2c3d4e5f6g7h8i9j0k1l2"
}
```

### 方式2：直接提供 previous_sql

如果不想使用会话ID，可以直接提供上一轮的 SQL：

**Request**:
```bash
curl -X POST http://localhost:8080/api/v1/sql/generate \
  -H "Authorization: Bearer your-api-key" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "还要筛选状态为active的用户",
    "schema": {
      "tables": [
        {
          "name": "users",
          "columns": [
            {"name": "id", "type": "int"},
            {"name": "name", "type": "varchar(100)"},
            {"name": "age", "type": "int"},
            {"name": "status", "type": "varchar(20)"}
          ]
        }
      ]
    },
    "database": {
      "type": "mysql",
      "version": "8.0"
    },
    "previous_sql": "SELECT * FROM users WHERE age > 30"
  }'
```

**Response**:
```json
{
  "sql": "SELECT * FROM users WHERE age > 30 AND status = '\''active'\''",
  "explanation": "在原有查询基础上增加了状态筛选条件",
  "conversation_id": "conv_def456ghi789jkl012mno345pqr"
}
```

## 注意事项

1. **Schema/Database 可选**：续会话时，`schema` 和 `database` 可省略，系统会从上下文复用；若显式传入则需与历史一致。

3. **会话过期**：会话在 24 小时未使用后会自动清理。如果使用已过期的 `conversation_id`，会返回 `CONVERSATION_NOT_FOUND` 错误。

4. **优先级**：如果同时提供 `conversation_id` 和 `previous_sql`，系统会优先使用 `previous_sql`。

5. **新会话**：如果不提供 `conversation_id` 和 `previous_sql`，系统会创建新会话。

## 错误码

| 错误码 | HTTP状态码 | 说明 |
|--------|-----------|------|
| `CONVERSATION_NOT_FOUND` | 404 | conversation_id 不存在或已过期 |
| `SCHEMA_MISMATCH` | 400 | schema 与历史会话不一致 |
| `DATABASE_MISMATCH` | 400 | database 与历史会话不一致 |
| `SQL_VALIDATION_FAILED` | 400 | 生成的 SQL 校验失败 |
| `LLM_ERROR` | 500 | LLM 调用失败 |

## 最佳实践

1. **保存 conversation_id**：第一轮请求后，保存返回的 `conversation_id`，用于后续请求。

2. **保持 Schema 一致**：在同一会话中，保持 `schema` 和 `database` 参数一致。

3. **明确修改意图**：在追加修改时，明确描述需要添加或修改的条件，例如：
   - ✅ "还要筛选状态为active的用户"
   - ✅ "增加按年龄排序"
   - ❌ "修改一下"（不够明确）

4. **错误处理**：如果收到 `CONVERSATION_NOT_FOUND` 错误，可以重新开始新会话或使用 `previous_sql` 方式。
